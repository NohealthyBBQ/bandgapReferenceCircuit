import struct
import re
import numpy as np
import collections



def split(plotDat, paramLabels=None):
    """ Splits the data (which is an ordered dictionary) into an array of ordered
    dictionaries if the data has come from a parametric analysis. If the
    analysis is not parametric, the size of the array is 1.
    """
    sweep = plotDat[plotDat.keys()[0]]
    splitPos = np.argwhere(sweep == sweep[0])

    if (paramLabels == None):
        paramLabels = range(len(splitPos))

    plotDatSplit = {}
    splitPtr = 0;
    splitPos = np.append(splitPos, len(sweep))
    for param in paramLabels:
        plotDatSplit[param] = collections.OrderedDict()
        for k in plotDat:
            plotDatSplit[param][k] = plotDat[k][splitPos[splitPtr]:splitPos[splitPtr + 1]]
        splitPtr += 1
    
    return plotDatSplit

def read(fileName):
    """ Reads a SPICE3RAW file and stores the data. Returns an array of ordered
    dictionaries containing arrays of the simulated data. The number of ordered
    dictionaries is greater than 1 for a analysis.

    Arguments:
    filename : A valid SPICE3 rawfile
    """
    rawFile = open(fileName, 'rb')
    dataBytes = rawFile.read()
    dataStr = str(dataBytes)
    
    simStarts = [m.start() for m in re.finditer('Title', dataStr)]
    plotDat = collections.OrderedDict()

    for startPtr in simStarts:
        flagStart = dataBytes.find(b'Flags: ', startPtr) + len('Flags: ')
        flags = dataBytes[flagStart:flagStart+4].decode()
        
        if flags == 'real':
        
            # Extract the number of variables
            startPos = dataBytes.find(b'No. Variables: ', startPtr) + len('No. Variables: ')
            endPos = dataBytes.find(b'No. Points:', startPtr)
            numVars = int(dataBytes[startPos:endPos].decode())

            #Extract the number of points
            startPos = endPos + len('No. Points: ')
            endPos = dataBytes.find(b'Variables:', startPos)
            numPoints = int(dataBytes[startPos:endPos].decode())
        
            #Extract variable names
            startPos = endPos + len('Variables:')
            endPos = dataBytes.find(b'Binary:', startPtr)
            varList = dataBytes[startPos:endPos].decode().split()
            
            # Create arrays to store the points
            for j in range(numVars):
                plotDat[(varList[j*3 + 1], varList[j*3 + 2])] = np.zeros(numPoints)
            
            # Populate the arrays
            bytePtr = endPos + len('Binary:\n')
            for j in range(numPoints):
                for k in plotDat.keys():
                    plotDat[k][j] = struct.unpack('d', dataBytes[bytePtr:bytePtr+8])[0]
                    bytePtr += 8
    return split(plotDat)

def getVars(plotDat):
    """ Returns the list of variable names and their units, i.e. the indices
    for the ordered dictionaries that read generates.
    """
    return plotDat[0].keys()

def plot(plotDat, xVar, yVar, color='b'):
    """ Plots the specified variables stored in plotDat. If the simulation is
    parametric, each of the parametric simulations are plotted.

    Arguments:
    plotDat - The data generated by the read function
    xVar - The variable on the horizontal axis
    yVar - The variable on the vertical axis
    color - The color of the line plot (defaul blue).
    """
    import matplotlib.pyplot as plt
    for rec in plotDat:
        lines = plt.plot(plotDat[rec][xVar], plotDat[rec][yVar], c=color)
        color = lines[0].get_color()
    plt.show()

